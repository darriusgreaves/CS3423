/*
// Sample Test Test2oo Question 3
//	Problem:
//		Write a C program which will create a total of 33 processes all of which will
//		have their own seperate pipe, i.e. all processes must be able to write to all
//		other processes but each will only read from its own pipe.  Each process will
//		be assigned a unique index 0, 1, ..., 32.  The original process will send an 
//		integer generated by rand() to processes 1, 2, ..., 32.  Each child will read
//		the number from its pipe and, if even, will write to the parent (process 0) the
//		random number read, its pid, and its index.  The original parent (process 0)
//		will read each messages and print a message similar to:
//			Original Process 0 reads random number 3157 from process 35993 index 17
//		Be careful that your code doesn't hang and messages don't get mixed up! 
*/

#include <stdio.h>		// printf, perror, fflush 
#include <stdlib.h>		// exit, srand, rand
#include <unistd.h>		// (POSIX) fork, pipe, read, write, getpid, close
#include <sys/types.h>	// (POSIX) pid_t
#include <time.h>		// time - for seeding rand()

#define NUM_PROCS   33  // Number of processes to create


int main(void){
	
	int i;		        		// loop variables
	int pipes[NUM_PROCS][2];	// pipes for all the processes
	int idx;                    // process index
	int parent;                 // parent of fork
	int random;					// holds random number to write

	// message struct used to send and recieve messages
	struct message {
		int index;
		int randNum;
		pid_t pid;
	} msg;

	// for testing purposes, seeding rand() with time
	int seed = time(NULL);
	srand(seed);

	// Set up the pipes
	for(i = 0; i < NUM_PROCS; i++){
		if(pipe(pipes[i]) == -1) {
			perror("pipe");
			exit(-1);
	}	}

	// fork all the processes
	for(i = 0; i < NUM_PROCS; i++){
		switch(parent = fork()){
			case -1:
				perror("fork");
				exit(-1);
			case 0:
				idx = i;
				parent = 0;
				break;
			default:
				parent = 1;
				break;
		}

		// child breaks out of fork loop
		if(parent == 0){
			break;
		}
	}

	// parent exits, not waiting for childern
	if(parent == 1){
		exit(0);
	}
	
	//  child closes read end of all pipes except its own
	for(i = 0; i < NUM_PROCS; i++){
		if(idx != i){
			close(pipes[i][0]);
	}	}
   
	// if proc 0 - send rand number to other procs, and read msg sent
	if(idx == 0){
		// msg to write
		random = rand();

		// send message to other processes
		for(i = 1; i < NUM_PROCS; i++){
			if(write(pipes[i][1], &random, sizeof(random)) != sizeof(random)){
				perror("write");
				exit(-1);
		}	}

		// close all the write ends of pipes
		for(i = 0; i < NUM_PROCS; i++){
			if(idx != i){
				close(pipes[i][1]);
		}	}

		// read messages sent
		while(read(pipes[0][0], &msg, sizeof(msg)) == sizeof(msg)){		
			printf("Original Process 0 reads random number %d from process %d index %d\n", msg.randNum, msg.pid, msg.index);
			fflush(stdout);
		}

		// close and exit
		close(pipes[0][0]);
		exit(0);
	}

	// otherwise (not proc 0)
	// close the write ends of all pipes except proc 0
	for (i = 0; i < NUM_PROCS; ++i)
	{
		if(i != 0){
			close(pipes[i][1]);
	}	}

	// child reads single message from proc 0
	if(read(pipes[idx][0], &random, sizeof(random)) != sizeof(random)){
		perror("read");
		exit(-1);
	}
	
	// if number is even, write back to proc 0
	if(random % 2 == 0){
		msg.randNum = random;
		msg.index = idx;
		msg.pid = getpid();
		if(write(pipes[0][1], &msg, sizeof(msg)) != sizeof(msg)){
			perror("write");
			exit(-1);
	} 	}

	// child closes remaining pipes and exits
	close(pipes[idx][0]);
	close(pipes[0][1]);
	exit(0);	
}
